#!/usr/bin/env python
# vim:fileencoding=UTF-8:ts=4:sw=4:sta:et:sts=4:ai

__license__   = 'GPL v3'
__copyright__ = '2010, Kovid Goyal <kovid@kovidgoyal.net>'
__docformat__ = 'restructuredtext en'

from functools import partial
from collections import defaultdict

from PyQt4.Qt import (Qt, QLineEdit, QDialog, QGridLayout, QLabel, QCheckBox,
                      QIcon, QDialogButtonBox, QColor, QComboBox, QPushButton)

from calibre.ebooks.metadata.book.base import composite_formatter
from calibre.gui2.dialogs.template_dialog import TemplateDialog
from calibre.gui2.complete import MultiCompleteLineEdit
from calibre.gui2 import error_dialog
from calibre.utils.icu import sort_key

class TemplateLineEditor(QLineEdit):

    '''
    Extend the context menu of a QLineEdit to include more actions.
    '''

    def __init__(self, parent):
        QLineEdit.__init__(self, parent)
        self.tags = None
        self.mi   = None
        self.txt = None

    def set_mi(self, mi):
        self.mi = mi

    def set_db(self, db):
        self.db = db

    def contextMenuEvent(self, event):
        menu = self.createStandardContextMenu()
        menu.addSeparator()

        action_clear_field = menu.addAction(_('Remove any template from the box'))
        action_clear_field.triggered.connect(self.clear_field)
        action_open_editor = menu.addAction(_('Open Template Editor'))
        action_open_editor.triggered.connect(self.open_editor)
        menu.exec_(event.globalPos())

    def clear_field(self):
        self.txt = None
        self.setText('')
        self.setReadOnly(False)
        self.setStyleSheet('TemplateLineEditor { color: black }')

    def open_editor(self):
        if self.txt:
            t = TemplateDialog(self, self.txt, self.mi)
        else:
            t = TemplateDialog(self, self.text(), self.mi)
        t.setWindowTitle(_('Edit template'))
        if t.exec_():
            self.txt = None
            self.setText(t.textbox.toPlainText())

    def enable_wizard_button(self, txt):
        if not txt or txt.startswith('program:\n#tag wizard'):
            return True
        return False

    def setText(self, txt):
        txt = unicode(txt)
        if txt and txt.startswith('program:\n#tag wizard'):
            self.txt = txt
            self.setReadOnly(True)
            QLineEdit.setText(self, '')
            QLineEdit.setText(self, _('Template generated by the wizard'))
            self.setStyleSheet('TemplateLineEditor { color: gray }')
        else:
            QLineEdit.setText(self, txt)

    def tag_wizard(self):
        txt = unicode(self.text())
        if txt and not self.txt:
            error_dialog(self, _('Invalid text'),
                 _('The text in the box was not generated by this wizard'),
                 show=True, show_copy_button=False)
            return
        d = TagWizard(self, self.db, unicode(self.txt), self.mi)
        if d.exec_():
            self.setText(d.template)

    def text(self):
        if self.txt:
            return self.txt
        return QLineEdit.text(self)

class TagWizard(QDialog):

    text_template              = ("        strcmp(field('{f}'), '{v}', '{ltv}', '{eqv}', '{gtv}')", True)
    text_empty_template        = ("        test(field('{f}'), '{fv}', '{tv}')", False)
    text_re_template           = ("        contains(field('{f}'), '{v}', '{tv}', '{fv}')", False)

    templates = {
        'text.mult'            : ("        str_in_list(field('{f}'), '{mult}', '{v}', '{tv}', '{fv}')", False),
        'text.mult.re'         : ("        in_list(field('{f}'), '{mult}', '^{v}$', '{tv}', '{fv}')", False),
        'text.mult.empty'      : ("        test(field('{f}'), '{fv}', '{tv}')", False),
        'text'                 : text_template,
        'text.re'              : text_re_template,
        'text.empty'           : text_empty_template,
        'rating'               : ("        cmp(raw_field('{f}'), '{v}', '{ltv}', '{eqv}', '{gtv}')", True),
        'rating.empty'         : text_empty_template,
        'int'                  : ("        cmp(raw_field('{f}'), '{v}', '{ltv}', '{eqv}', '{gtv}')", True),
        'int.empty'            : text_empty_template,
        'float'                : ("        cmp(raw_field('{f}'), '{v}', '{ltv}', '{eqv}', '{gtv}')", True),
        'float.empty'          : text_empty_template,
        'bool'                 : ("        strcmp(field('{f}'), '{v}', '{ltv}', '{eqv}', '{gtv}')", True),
        'bool.empty'           : text_empty_template,
        'datetime'             : ("        strcmp(format_date(raw_field('{f}'), 'yyyyMMdd'), format_date('{v}', 'yyyyMMdd'), '{ltv}', '{eqv}', '{gtv}')", True),
        'datetime.empty'       : text_empty_template,
        'series'               : text_template,
        'series.re'            : text_re_template,
        'series.empty'         : text_empty_template,
        'composite'            : text_template,
        'composite.re'         : text_re_template,
        'composite.empty'      : text_empty_template,
        'enumeration'          : text_template,
        'enumeration.re'       : text_re_template,
        'enumeration.empty'    : text_empty_template,
        'comments'             : text_template,
        'comments.re'          : text_re_template,
        'comments.empty'       : text_empty_template,
    }

    relationals = ('=', '!=', '<', '>', '<=', '>=')
    relational_truth_vals = {
        '=':        ('', '1', ''),
        '!=':       ('1', '', '1'),
        '<':        ('1', '', ''),
        '>':        ('', '', '1'),
        '<=':       ('1', '1', ''),
        '>=':       ('', '1', '1'),
    }

    @staticmethod
    def uses_this_wizard(txt):
        if not txt or txt.startswith('program:\n#tag wizard'):
            return True
        return False

    def __init__(self, parent, db, txt, mi):
        QDialog.__init__(self, parent)
        self.setWindowTitle(_('Coloring Wizard'))
        self.setWindowIcon(QIcon(I('wizard.png')))

        self.mi = mi

        self.columns = []
        self.completion_values = defaultdict(dict)
        for k in db.all_field_keys():
            m = db.metadata_for_field(k)
            if k.endswith('_index') or (
                    m['kind'] == 'field' and m['name'] and
                    k not in ('ondevice', 'path', 'size', 'sort')):
                self.columns.append(k)
                self.completion_values[k]['dt'] = m['datatype']
                if m['is_custom']:
                    if m['datatype'] in ('int', 'float'):
                        self.completion_values[k]['v'] = []
                    elif m['datatype'] == 'bool':
                        self.completion_values[k]['v'] = [_('Yes'), _('No')]
                    else:
                        self.completion_values[k]['v'] = db.all_custom(m['label'])
                elif k == 'tags':
                    self.completion_values[k]['v'] = db.all_tags()
                elif k == 'formats':
                    self.completion_values[k]['v'] = db.all_formats()
                else:
                    if k in ('publisher'):
                        ck = k + 's'
                    else:
                        ck = k
                    f = getattr(db, 'all_' + ck, None)
                    if f:
                        if k == 'authors':
                            self.completion_values[k]['v'] = [v[1].\
                                                replace('|', ',') for v in f()]
                        else:
                            self.completion_values[k]['v'] = [v[1] for v in f()]
                    else:
                            self.completion_values[k]['v'] = []

                if k in self.completion_values:
                    if k == 'authors':
                        mult = '&'
                    else:
                        mult = ',' if m['is_multiple'] == '|' else m['is_multiple']
                    self.completion_values[k]['m'] = mult

        self.columns.sort(key=sort_key)
        self.columns.insert(0, '')

        l = QGridLayout()
        self.setLayout(l)
        l.setColumnStretch(2, 10)
        l.setColumnMinimumWidth(5, 300)

        h = QLabel(_('And'))
        h.setToolTip('<p>' +
             _('Set this box to indicate that the two conditions must both '
               'be true to use the color. For example, you '
               'can check if two tags are present, if the book has a tag '
               'and a #read custom column is checked, or if a book has '
               'some tag and has a particular format.'))
        l.addWidget(h, 0, 0, 1, 1)

        h = QLabel(_('Column'))
        h.setAlignment(Qt.AlignCenter)
        l.addWidget(h, 0, 1, 1, 1)

        h = QLabel(_('is'))
        h.setAlignment(Qt.AlignCenter)
        l.addWidget(h, 0, 2, 1, 1)

        h = QLabel(_('op'))
        h.setToolTip('<p>' +
             _('Use this box to tell what comparison operation to use. Some '
               'comparisons cannot be used with certain options. For example, '
               'if regular expressions are used, only equals and not equals '
               'are valid.') + '</p>')
        h.setAlignment(Qt.AlignCenter)
        l.addWidget(h, 0, 3, 1, 1)

        c = QLabel(_('empty'))
        c.setToolTip('<p>' +
             _('Check this box to check if the column is empty') + '</p>')
        l.addWidget(c, 0, 4, 1, 1)

        h = QLabel(_('Values'))
        h.setAlignment(Qt.AlignCenter)
        h.setToolTip('<p>' +
             _('You can enter more than one value per box, separated by commas. '
               'The comparison ignores letter case. Special note: authors are '
               'separated by ampersands (&).<br>'
               'A value can be a regular expression. Check the box to turn '
               'them on. When using regular expressions, note that the wizard '
               'puts anchors (^ and $) around the expression, so you '
               'must ensure your expression matches from the beginning '
               'to the end of the column/value you are checking.<br>'
               'Regular expression examples:') + '<ul>' +
             _('<li><code><b>.*</b></code> matches anything in the column.</li>'
               '<li><code><b>A.*</b></code> matches anything beginning with A</li>'
               '<li><code><b>.*mystery.*</b></code> matches anything containing '
               'the word "mystery"</li>') + '</ul></p>')
        l.addWidget(h , 0, 5, 1, 1)

        c = QLabel(_('is RE'))
        c.setToolTip('<p>' +
             _('Check this box if the values box contains regular expressions') + '</p>')
        l.addWidget(c, 0, 6, 1, 1)

        c = QLabel(_('color'))
        c.setAlignment(Qt.AlignCenter)
        c.setToolTip('<p>' +
             _('Use this color if the column matches the tests.') + '</p>')
        l.addWidget(c, 0, 7, 1, 1)

        self.andboxes       = []
        self.opboxes        = []
        self.tagboxes       = []
        self.colorboxes     = []
        self.reboxes        = []
        self.colboxes       = []
        self.emptyboxes     = []

        self.colors = [unicode(s) for s in list(QColor.colorNames())]
        self.colors.insert(0, '')

        def create_widget(klass, box, layout, row, col, items,
                          align=Qt.AlignCenter, rowspan=False):
            w = klass(self)
            if box is not None:
                box.append(w)
            if rowspan:
                layout.addWidget(w, row, col, 2, 1, alignment=Qt.Alignment(align))
            else:
                layout.addWidget(w, row, col, 1, 1, alignment=Qt.Alignment(align))
            if items:
                w.addItems(items)
            return w

        maxlines = 10
        for i in range(1, maxlines+1):
            w = create_widget(QCheckBox, self.andboxes, l, i, 0, None, rowspan=True)
            w.stateChanged.connect(partial(self.and_box_changed, line=i-1))
            if i == maxlines:
                # last box is invisible
                w.setVisible(False)

            w = create_widget(QComboBox, self.colboxes, l, i, 1, self.columns)
            w.currentIndexChanged[str].connect(partial(self.column_changed, line=i-1))

            w = QLabel(self)
            w.setText(_('is'))
            l.addWidget(w, i, 2, 1, 1)

            w = create_widget(QComboBox, self.opboxes, l, i, 3, None)
            w.setMaximumWidth(40)

            w = create_widget(QCheckBox, self.emptyboxes, l, i, 4, None)
            w.stateChanged.connect(partial(self.empty_box_changed, line=i-1))

            create_widget(MultiCompleteLineEdit, self.tagboxes, l, i, 5, None, align=0)

            w = create_widget(QCheckBox, self.reboxes, l, i, 6, None)
            w.stateChanged.connect(partial(self.re_box_changed, line=i-1))

            create_widget(QComboBox, self.colorboxes, l, i, 7, self.colors)

        w = create_widget(QLabel, None, l, maxlines+1, 5, None)
        w.setText(_('If none of the tests match, set the color to'))
        self.elsebox = create_widget(QComboBox, None, l, maxlines+1, 7, self.colors)
        self.elsebox.setToolTip('<p>' +
                    _('If this box contains a color, it will be used if none '
                      'of the above rules match.')  + '</p>')

        if txt:
            lines = txt.split('\n')[3:]
            i = 0
            for line in lines:
                if line.startswith('#'):
                    vals = line[1:].split(':|:')
                    if len(vals) == 1 and line.startswith('#else:'):
                        try:
                            self.elsebox.setCurrentIndex(self.elsebox.findText(line[6:]))
                        except:
                            pass
                        continue
                    if len(vals) == 2:
                        t, c = vals
                        f = 'tags'
                        a = re = e = 0
                        op = '='
                    else:
                        t,c,f,re,a,op,e = vals
                    try:
                        self.colboxes[i].setCurrentIndex(self.colboxes[i].findText(f))
                        self.colorboxes[i].setCurrentIndex(
                                                self.colorboxes[i].findText(c))
                        self.tagboxes[i].setText(t)
                        self.reboxes[i].setChecked(re == '2')
                        self.emptyboxes[i].setChecked(e == '2')
                        self.andboxes[i].setChecked(a == '2')
                        self.opboxes[i].setCurrentIndex(self.opboxes[i].findText(op))
                        i += 1
                    except:
                        import traceback
                        traceback.print_exc()
                        pass

        w = QLabel(_('Preview'))
        l.addWidget(w, 99, 1, 1, 1)
        w = self.test_box = QLineEdit(self)
        w.setReadOnly(True)
        l.addWidget(w, 99, 2, 1, 5)
        w = QPushButton(_('Test'))
        w.setToolTip('<p>' +
                     _('Press this button to see what color this template will '
                       'produce for the book that was selected when you '
                       'entered the preferences dialog.'))
        l.addWidget(w, 99, 7, 1, 1)
        w.clicked.connect(self.preview)

        bb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel, parent=self)
        l.addWidget(bb, 100, 5, 1, 3)
        bb.accepted.connect(self.accepted)
        bb.rejected.connect(self.reject)
        self.template = ''

    def preview(self):
        if not self.generate_program():
            return
        t = composite_formatter.safe_format(self.template, self.mi,
                                            _('EXCEPTION'), self.mi)
        self.test_box.setText(t)

    def generate_program(self):
        res = ("program:\n#tag wizard -- do not directly edit\n"
               "  first_non_empty(\n")
        lines = []
        was_and = had_line = False

        line = 0
        for tb, cb, fb, reb, ab, ob, eb in zip(
                self.tagboxes, self.colorboxes, self.colboxes,
                self.reboxes, self.andboxes, self.opboxes, self.emptyboxes):
            f = unicode(fb.currentText())
            if not f:
                continue
            m = self.completion_values[f]['m']
            dt = self.completion_values[f]['dt']
            c = unicode(cb.currentText()).strip()
            re = reb.checkState()
            a  = ab.checkState()
            op = unicode(ob.currentText())
            e  = eb.checkState()
            line += 1

            if m:
                tags = [t.strip() for t in unicode(tb.text()).split(m) if t.strip()]
                if re == 2:
                    tags = '$|^'.join(tags)
                else:
                    tags = m.join(tags)
                if m == '&':
                    tags = tags.replace(',', '|')
            else:
                tags = unicode(tb.text()).strip()

            if (tags or f) and not ((tags or e) and f and (a == 2 or c)):
                error_dialog(self, _('Invalid line'),
                             _('Line number {0} is not valid').format(line),
                             show=True, show_copy_button=False)
                return False

            if not was_and:
                if had_line:
                    lines[-1] += ','
                had_line = True
                lines.append("    test(and(")
            else:
                lines[-1] += ','

            key = dt + ('.mult' if m else '') + ('.empty' if e else '') + ('.re' if re else '')
            tval = '1' if op == '=' else ''
            fval = ''  if op == '=' else '1'
            template, is_relational = self.templates[key]
            if is_relational:
                ltv, eqv, gtv = self.relational_truth_vals[op]
            else:
                ltv, eqv, gtv = (None, None, None)
            lines.append(template.format(v=tags, f=f, tv=tval, fv=fval, mult=m,
                                         ltv=ltv, eqv=eqv, gtv=gtv))

            if a == 2:
                was_and = True
            else:
                was_and = False
                lines.append("    ), '{0}', '')".format(c))

        res += '\n'.join(lines)
        else_txt = unicode(self.elsebox.currentText())
        if else_txt:
            res += ",\n  '" + else_txt + "'"
        res += ')\n'
        self.template = res
        res = ''
        for tb, cb, fb, reb, ab, ob, eb in zip(
                self.tagboxes, self.colorboxes, self.colboxes,
                self.reboxes, self.andboxes, self.opboxes, self.emptyboxes):
            t = unicode(tb.text()).strip()
            if t.endswith(','):
                t = t[:-1]
            c = unicode(cb.currentText()).strip()
            f = unicode(fb.currentText())
            re = unicode(reb.checkState())
            a = unicode(ab.checkState())
            op = unicode(ob.currentText())
            e = unicode(eb.checkState())
            if f and (t or e) and (a == '2' or c):
                res += '#' + t + ':|:' + c  + ':|:' + f + ':|:' + re + ':|:' + \
                             a + ':|:' + op + ':|:' + e + '\n'
        res += '#else:' + else_txt + '\n'
        self.template += res
        return True

    def column_changed(self, s, line=None):
        k = unicode(s)
        valbox = self.tagboxes[line]
        if k in self.completion_values:
            valbox.update_items_cache(self.completion_values[k]['v'])
            if self.completion_values[k]['m']:
                valbox.set_separator(', ')
            else:
                valbox.set_separator(None)

            dt = self.completion_values[k]['dt']
            if dt in ('int', 'float', 'rating', 'bool'):
                self.reboxes[line].setChecked(0)
                self.reboxes[line].setEnabled(False)
            else:
                self.reboxes[line].setEnabled(True)
            self.fill_in_opbox(line)
        else:
            valbox.update_items_cache([])
            valbox.set_separator(None)

    def fill_in_opbox(self, line):
        opbox = self.opboxes[line]
        opbox.clear()
        k = unicode(self.colboxes[line].currentText())
        if not k:
            return
        if k in self.completion_values:
            rebox = self.reboxes[line]
            ebox = self.emptyboxes[line]
            idx = opbox.currentIndex()
            if self.completion_values[k]['m'] or \
                    rebox.checkState() == 2 or ebox.checkState() == 2:
                opbox.addItems(self.relationals[0:2])
                idx = idx if idx < 2 else 0
            else:
                opbox.addItems(self.relationals)
            opbox.setCurrentIndex(max(idx, 0))

    def re_box_changed(self, state, line=None):
        self.fill_in_opbox(line)

    def empty_box_changed(self, state, line=None):
        if state == 2:
            self.tagboxes[line].setText('')
            self.tagboxes[line].setEnabled(False)
            self.reboxes[line].setChecked(0)
            self.reboxes[line].setEnabled(False)
        else:
            self.reboxes[line].setEnabled(True)
            self.tagboxes[line].setEnabled(True)
        self.fill_in_opbox(line)

    def and_box_changed(self, state, line=None):
        if state == 2:
            self.colorboxes[line].setCurrentIndex(0)
            self.colorboxes[line].setEnabled(False)
        else:
            self.colorboxes[line].setEnabled(True)

    def accepted(self):
        if self.generate_program():
            self.accept()
        else:
            self.template = ''
