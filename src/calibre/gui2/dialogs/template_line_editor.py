#!/usr/bin/env python
# vim:fileencoding=UTF-8:ts=4:sw=4:sta:et:sts=4:ai

__license__   = 'GPL v3'
__copyright__ = '2010, Kovid Goyal <kovid@kovidgoyal.net>'
__docformat__ = 'restructuredtext en'

from PyQt4.Qt import (QLineEdit, QDialog, QGridLayout, QLabel,
                      QDialogButtonBox, QColor, QComboBox, QIcon)

from calibre.gui2.dialogs.template_dialog import TemplateDialog
from calibre.gui2.complete import MultiCompleteComboBox
from calibre.gui2 import error_dialog

class TemplateLineEditor(QLineEdit):

    '''
    Extend the context menu of a QLineEdit to include more actions.
    '''

    def __init__(self, parent):
        QLineEdit.__init__(self, parent)
        self.tags = None

    def set_tags(self, tags):
        self.tags = tags

    def contextMenuEvent(self, event):
        menu = self.createStandardContextMenu()
        menu.addSeparator()

        action_open_editor = menu.addAction(_('Open Template Editor'))
        action_open_editor.triggered.connect(self.open_editor)
        if self.tags:
            action_tag_wizard = menu.addAction(_('Open Tag Wizard'))
            action_tag_wizard.triggered.connect(self.tag_wizard)
        menu.exec_(event.globalPos())

    def open_editor(self):
        t = TemplateDialog(self, self.text())
        t.setWindowTitle(_('Edit template'))
        if t.exec_():
            self.setText(t.textbox.toPlainText())

    def tag_wizard(self):
        txt = unicode(self.text())
        if txt and not txt.startswith('program:\n#tag wizard'):
            error_dialog(self, _('Invalid text'),
                 _('The text in the box was not generated by this wizard'),
                 show=True, show_copy_button=False)
            return
        d = TagWizard(self, self.tags, unicode(self.text()))
        if d.exec_():
            self.setText(d.template)

class TagWizard(QDialog):

    def __init__(self, parent, tags, txt):
        QDialog.__init__(self, parent)
        self.setWindowTitle(_('Tag Wizard'))
        self.setWindowIcon(QIcon(I('wizard.png')))

        self.tags = tags
        l = QGridLayout()
        self.setLayout(l)
        l.setColumnStretch(0, 1)
        l.addWidget(QLabel(_('Tag Value')), 0, 0, 1, 1)
        l.addWidget(QLabel(_('Color')), 0, 1, 1, 1)
        self.tagboxes = []
        self.colorboxes = []
        self.colors = [unicode(s) for s in list(QColor.colorNames())]
        self.colors.insert(0, '')
        for i in range(0, 10):
            tb = MultiCompleteComboBox(self)
            tb.set_separator(', ')
            tb.update_items_cache(self.tags)
            self.tagboxes.append(tb)
            l.addWidget(tb, i+1, 0, 1, 1)
            cb = QComboBox(self)
            cb.addItems(self.colors)
            self.colorboxes.append(cb)
            l.addWidget(cb, i+1, 1, 1, 1)

        if txt:
            lines = txt.split('\n')[3:]
            i = 0
            for line in lines:
                if line.startswith('#'):
                    t,c = line[1:].split(':|:')
                    try:
                        self.colorboxes[i].setCurrentIndex(self.colorboxes[i].findText(c))
                        self.tagboxes[i].setText(t)
                    except:
                        pass
                    i += 1

        bb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel, parent=self)
        l.addWidget(bb, 100, 1, 1, 1)
        bb.accepted.connect(self.accepted)
        bb.rejected.connect(self.reject)
        self.template = ''

    def accepted(self):
        res = ("program:\n#tag wizard -- do not directly edit\n"
               "    t = field('tags');\n  first_non_empty(\n")
        lines = []
        for tb, cb in zip(self.tagboxes, self.colorboxes):
            tags = [t.strip() for t in unicode(tb.currentText()).split(',') if t.strip()]
            c = unicode(cb.currentText()).strip()
            if not tags or not c:
                continue
            if c not in self.colors:
                error_dialog(self, _('Invalid color'),
                             _('The color {0} is not valid').format(c),
                             show=True, show_copy_button=False)
                return False
            for t in tags:
                lines.append("    in_list(t, ',', '^{0}$', '{1}', '')".format(t, c))
        res += ',\n'.join(lines)
        res += ')\n'
        self.template = res
        res = ''
        for tb, cb in zip(self.tagboxes, self.colorboxes):
            t = unicode(tb.currentText()).strip()
            if t.endswith(','):
                t = t[:-1]
            c = unicode(cb.currentText()).strip()
            if t and c:
                res += '#' + t + ':|:' + c  + '\n'
        self.template += res
        self.accept()
